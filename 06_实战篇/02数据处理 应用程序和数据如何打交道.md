# 数据处理: 应用程序和数据如何打交道?

我们开发者无论是从事服务端的开发, 还是客户端的开发, 和数据打交道是必不可少的

对于客户端来说, 从服务端读取到数据, 往往需要做缓存(内存缓存或者SQLite缓存), 甚至需要本地存储(文件或者SQLite)

对于服务器来说, 跟数据打交道的场景就更加丰富了, 除了数据库和缓存外, 还有大量的文本数据的索引(比如搜索引擎), 实时的消息队列对数据做流式处理, 或者非实时的批理对数据仓库(data wareouse)中的海量数据就进行ETL(Extract, Transfrom and Load)

![image-20241225164622329](assets/image-20241225164622329.png)

今天我们就来讲讲如何用Rust做数据处理, 主要讲两部分, 如何用Rust访问关系数据库, 以及如何用Rust对半结构化数据进行分析和处理, 希望通过学习这一讲的内容, 尤其是后半部分的内容, 能帮你打开眼界, 对数据处理有更加深刻的认识

## 访问关系数据库

作为互联网应用的最主要的数据存储和访问工具, 关系数据库, 是几乎没门编程语言都有良好支持的数据库类型

在Rust下, 有几乎所有主流关系数据库的驱动, 比如rust-postgres, rust-mysql-simple等, 不过一般我们不太会直接使用数据库的驱动来访问数据库, 因为那样会让应用过于耦合与某个数据库, 所以我们会使用ORM

Rust下有diesel这个非常成熟的ORM, 还有sea-orm这样的后起之秀, diesel不支持异步, 而sea-orm支持异步, 所以有理由相信, 随着sea-orm的不断程序, 会有越来越多的应用在sea-orm上构建

如果你觉得ORM太过笨重, 繁文缛节太多, 但又不想直接使用某个数据的驱动来访问数据, 那么你还可以用sqlx, sqlx提供了对多种数据的异步访问支持, 并且不使用DSL就可以对SQL query做编译时检查, 非常轻便; 它可以从数据库中直接查询出来一行数据, 也可以通过派生宏自行把行数据转换成对应的结构

今天, 我们就尝试使用sqlx处理用户注册和登陆两个非常常见的功能

## sqlx

构建下面的表结构来处理用户登陆信息:

```sql
CREATE TABLE IF NOT EXISTS users
(
    id INTEGER PRIMARY KEY NOT NULL,
    email VARCHAR UNIQUE NOT NULL,
    hashed_password VARCHAR NOT NULL
);
```

