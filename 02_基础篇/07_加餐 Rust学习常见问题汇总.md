# 加餐: Rust学习常见问题汇总

到目前为止, 我们已经学了很多Rust的知识, 比如基本语法, 内存管理, 所有权, 生命周期等, 也展示了三个非常有代表性的示例项目, 让你了解接近真实应用环境的Rust代码是什么样的

虽然学了这么多东西, 你是不是有种一学就会, 一些就废的感觉? 别着急, 饭要一口口吃, 任何新知识的学习都不是一蹴而就的, 我们让子弹飞一会,

在那天我们来聊一聊Rust开发中常见的问题, 希望可以解决你的一些困惑

## 所有权问题

**Q: 如果我想创建双向链表, 该怎么处理?**

Rust标准库有LinkedList, 它是一个双向链表实现, 但是当你需要使用链表的时候, 可以先考虑一下, 同样的需求是否可以用列表`Vec<T>`, 循环缓冲区`VecDeque<T>`来实现, 因为链表对缓存并不友好, 性能会差很多

如果你只是好奇如何实现双向链表, 那么可以用之前的Rc / RefCell来实现, 对于链表的next指针, 你可以用Rc; 对于prev指针可以用Weak

Weak相当于一个弱化版本的Rc, 不参与到引用计数的计算中, 而Weak可以可以upgrade到Rc来使用, 如果你用过其他引用计数语言, 你应该对Weak不陌生, 它可以榜我们打破循环引用

你也许好奇为什么Rust标准库的LinkedList不用Rc / Weak, 那是因为标准库直接使用NonNull指针和unsafe

**Q: 编译器总告诉我: "unse of moved value"错误该怎么办?**

这是我们初学Rust时经常会遇到的问题, 这个错误是说你在视图访问一个所有权已经被移动的变量

对于这个错误, 首先你要判断, 这个变量真的需要被移动到另一个作用域下吗? 如果不需要, 可不可以使用借用? 如果的确需要移动给另一个作用域的话:

1. 如果需要多个所有者共享同一份数据, 可以使用Rc / Arc, 辅以Cell / RefCell / MuTex / RwLock
2. 如果不需要多个所有者共享, 那么可以考虑实现Clone甚至Copy

## 生命周期

**Q: 为什么我的函数返回一个引用的时候, 编译器总是跟我过不去？**

函数返回引用时, 除非是静态引用. 那么这个引用一定和带有引用的某个输入参数有关, 输入参数可能是`&sefl`, `&mut self`或者`&T` / `&mut T`, 我们要建立正确的输入和返回值之间的关系, 这个关系和函数内部的实现无关, 只和函数的签名有关

比如HashMap的get方法

```rust
pub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>
where
K: Borrow<Q>,
Q: Hash + Eq
```

我们并不用实现它或者知道它如何实现, 就可以确定返回值`Option<&V>`到底跟谁有关, 因为这里只有两个选择: `&self`或者`k: &Q`显然是`&self`, 因为HashMap持有数据, 而k只是用来在HashMap里查询的key

这里为什么不需要使用生命周期参数呢? 因为我们之前讲的规则: 当`&self` / `&mut self`出现时, 返回值的生命周期和它关联, 这是一个很棒的规则, 因为大部分方法, 如果返回引用, 它基本上都是引用`&self`里的某个数据

如果你能搞清楚这一层关系, 那么就比较容易处理, 函数返回引用时出现的生命周期错误

当你要返回函数执行过程中, 创建的或者得到的数据, 和参数无关, 那么无论它是一个有所有权的数据, 还是一个引用, 你只能发那会带所有权的数据, 对于引用, 这就意味着调用clone或者to_owned来, 从引用中得到所有权

## 数据结构问题

**Q: 为什么Rust字符串这么混乱, 有String, `&String`, `&str`这么多不同的表述?**

我不得不说, 这是一个很有误导性的问题, 因为这个问题有点胡乱总结的倾向, 很容易把人带进沟里

首先任何数据结构T, 都可以有指向它的引用`&T`, 所以String跟`&String`的区别, 以及String和`&str`的区别是两个问题

更好的问题是: 为什么有了String还要有`&str`? 或者更通用的问题: 为什么String, `Vec<T>`这样存放连续数据的容器还要有切片这个概念呢?

一旦问到点子上, 答案不言而喻, 因为切片是一个非常通用的数据结构

用过Python的人都知道:

```python
s = "hello world"
let slice1 = s[:5] # 可以对字符串切片
let slice2 = slice1[1:3] # 可以对切片再切片
print(slice1, slice2) # 打印 hello, el
```

这个Rust的String切片何其相似:

```rust
let s = "hello world".to_string();
let slice1 = &s[..5]; // 可以对字符串切片
let slice2 = &slice1[1..3]; // 可以对切片再切片
println!("{} {}", slice1, slice2); // 打印 hello el
```

所以`&str`是String的切片, 也可以是`&str`的切片, 它和`&[T]`一样, 没有什么特别的, 就是一个带着长度的胖指针, 指向一片连续的内存区域

你可以这么理解: 切片之于`Vec<T>` / String等余数, 就好比数据里的视图(view)之于表(table)

**Q: 在课程示例代码中, 用了很多unwrap, 这样可以吗?**

当我们需要从Option或者`Result<T, E>`中获得数据的时, 可以使用unwrap方法, 这是实例代码出现unwrap的原因

如果我们这是写一些学习性质的代码, 那么unwrap是可以接受的, 但在生产环境中, 除非你可以确保unwrap不会引发panic!, 否则应该使用模式匹配来处理数据, 或者使用错误处理?操作符

那么什么情况下我们可以确定unwrap不会panic呢? 如果在做unwrap之前, `Option<T>`或者`Result<T, E>`中已经有了合适的值, 你就可以做unwrap

**Q: 为什么标准库的数据结构比如Rc / Vec用那么多的unsafe, 但别人总是告诉我unsafe不好?**

好问题, C语言的开发者也认为asm不好, 但C的很多库里也大量使用asm

标准库的责任是, 在保证安全的情况下, 即使牺牲一些可读性, 也要用最高效的手段来实现要实现的功能; 同时为标准库的用户提供一个优雅, 高级抽象, 让他们在绝大多数场合下写出漂亮的代码, 无需和丑陋打交道

Rust中, unsafe代码把程序的正确性和安全性交给开发者来保证, 而标准库的开发者花了大量的精力和测试来保证这种正确性和安全性, 而我们自己撰写unsafe代码的时, 除非有经验丰富的开发者review代码, 否则, 有可能疏于对并发情况的考虑, 写出问题的代码

所以只要不是必须, 建议不要写unsafe代码, 毕竟大部分我们要处理的问题, 都可以通过良好的设计, 合适的数据结构和算法来实现

**Q: 在Rust里, 我如何声明全局变量?**

在之前, 我们讲过const和static, 它们都可以用于声明全局变量, 但注意, 除非使用unsafe, static无法作为mut使用, 因为这意味着它可能在多个线程下被修改, 所以不安全

```rust
static mut COUNTER: u64 = 0;
fn main() {
    COUNTER += 1; // 编译不过，编译器告诉你需要使用 unsafe
}
```

如果你的确向用可写的全局变量, 可以用`Mutex<T>`, 然而, 初始化它很麻烦, 这是你可以用一个库lazy_static

```rust
use lazy_static::lazy_static;
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
lazy_static! {
    static ref HASHMAP: Arc<Mutex<HashMap<u32, &'static str>>> = {
        let mut m = HashMap::new();
        m.insert(0, "foo");
        m.insert(1, "bar");
        m.insert(2, "baz");
        Arc::new(Mutex::new(m))
    };
}
fn main() {
    let mut map = HASHMAP.lock().unwrap();
    map.insert(3, "waz");
    println!("map: {:?}", map);
}
```

## 调试工具

**Q: Rust下, 一般如何调试应用程序**

我自己一般会用tracing来打日志, 一些简单的示例代码会使用prinln / dbg, 来查看数据在某个时刻的状态, 而在平时开发中, 我几乎不会用调试器设置断点

与其浪费时间在调试上, 不如多花时间在设计上, 在实现的时候, 添加足够清晰的日志, 以及撰写合适的单元测试, 来保证代码逻辑上的正确性, 如果你发现自己总需要使用调试工具单步追踪才能搞清楚程序的状态, 说明代码没有设计好, 过于复杂

当我学习Rust时, 会常用调试工具查看内存信息, 后续的课程中我们会看到, 在分析有些数据结构时使用了这些工具

Rust下, 我们可以用rust-gdb或rust-llldb, 它们提供了一些对Rust更友好的pretty-print功能, 在安装Rust时, 它们也会被安装

## 其他问题

**Q: 为什么Rust编译出来的二进制那么大? 为什么Rust代码运行起来那么慢?**

如果你是用`cargo build`编译出来, 那很正常, 因为这是个debug build, 里面有大量的调试信息, 你可以用`cargo build --release`来编译出优化后的版本, 其实还有很多方法进一步友好, 可以自行了解

Rust的很多库如果你不用`--release`来编译, 它不会做任何优化, 有时候甚至感觉比你的Node还慢, 所以当你要把代码应用在生产环境, 一定要使用release build

## 思考题

来一道简单的思考题, 哦们把之前学过的内容融会贯通一下, 代码展示了有问题的生命周期, 你能找到原因吗?

```rust
use std::str::Chars;
// 错误，为什么？因为悬垂指针
fn lifetime1() -> &str {
    let name = "Tyr".to_string();
    &name[1..]
}
// 错误，为什么？悬垂指针
fn lifetime2(name: String) -> &str {
    &name[1..]
}
// 正确，为什么？因为编译器会默认加上生命周期, 输出生命周期等于输入的生命周期
fn lifetime3(name: &str) -> Chars {
    name.chars()
}
```

