# 数据结构: 这些结构竟然都是智能指针?

到目前为止, 我们学习了Rust的所有权, 生命周期, 内存管理, 类型系统, 基础知识里还剩下一块版图没有涉及: 数据结构, 数据结构里最容易让人困惑的就是智能指针, 所以我们今天就来解决这个难点

我们之前简单介绍过指针, 这里还是先回顾一下: 指针是一个持有内存地址的值, 可以通过解引用来访问指向它的内存地址, 理论上可以解引用到任意数据类型; 引用是一个特殊的指针, 它的解引用是受限的, 只能解引用到它引用数据的结构, 不能用作它用

那什么是智能指针呢?

## 智能指针

在指针和引用的基础上, Rust偷师C++, 提供了智能指针, 智能指针时一个表现行为很像指针的数据结构, 但除了指向数据的指针外, 它还有元数据以及提供额外的处理能力

这个定义有点模糊, 我们对比其他的数据结构来确定一下:

你有没有觉得很像之前讲的胖指针, 智能指针一定是一个胖指针, 但胖指针不一定是一个智能指针, 比如`&str`就是一个胖指针, 它有指向堆内存的字符串的指针, 同时还有关于字符串长度的元数据

我们看智能指针String和`&str`的区别:

![image-20241205155000784](assets/image-20241205155000784.png)

从图上可以看到, String除了多一个capacity字段, 似乎没有什么特殊, 但String对堆上的值有所有权, 而`&str`是没有所有权的, 这是Rust中智能指针和普通胖指针的区别

那么又有一个问题了, 智能指针和结构体有什么区别呢? 因为我们知道, String是用结构体定义的:

```rust
pub struct String {
    vec: Vec<u8>,
}
```

和普通结构体不同的是, String实现了Deref和DerefMut, 这使得它们在解引用的时候会得到`&str`, 看下面的标准库的实现:

```rust
impl ops::Deref for String {
    type Target = str;
    fn deref(&self) -> &str {
        unsafe { str::from_utf8_unchecked(&self.vec) }
    }
}
impl ops::DerefMut for String {
    fn deref_mut(&mut self) -> &mut str {
        unsafe { str::from_utf8_unchecked_mut(&mut *self.vec) }
    }
}
```

另外, 由于在堆上分配了数据, String还需要为其分配的资源做相应的回收, 而String内部使用了`Vec<u8>`, 所以它可以依赖`Vec<T>`的能力来释放堆内存, 下面是标准库中`Vec<T>`的Drop trait实现:

```rust
unsafe impl<#[may_dangle] T, A: Allocator> Drop for Vec<T, A> {
    fn drop(&mut self) {
        unsafe {
            // use drop for [T]
            // use a raw slice to refer to the elements of the vector as weake
            // could avoid questions of validity in certain cases
            ptr::drop_in_place(ptr::slice_from_raw_parts_mut(self.as_mut_ptr()
                }
                // RawVec handles deallocation
            }
        }
```

所以在清晰一下定义, 在Rust中, 凡是需要做资源回收的数据结构, 且实现了Deref / DerefMut / Drop, 都是智能指针

按照这个定义, 除了String, 在之前的课程中我们遇到了很多智能指针, 比如用于在堆上分配内存的`Box<T>`和`Vec<T>`, 用于引用计数的`Rc<T>`和`Arc<T>`, 很多其他的数据结构, 如PathBuf, `Cow<'a, B>`, `MutexGuard<T>`, `RwLockReadGuard<T>`和RwLockWriteGuard等也是智能指针

今天我们就深入分析三个使用智能指针的数据结构: 在堆上创建内存的`Box<T>`, 提供写时克隆的`Cow<'a, B>`, 以及用于数据加锁的`MutexGuard<T>`

而且最后我们会尝试实现自己的智能指针, 希望学完后你不但能更好的理解智能指针, 还能在需要的时候, 构建自己的智能指针来解决问题

## `Box<T>`

我们先看`Box<T>`, 它是Rust中最基础的在堆上分配内存的方式, 绝大多数其他包含在堆内存分配的数据结构, 内部都是通过`Box<T>`完成的, 比如`Vec<T>`

为什么有`Box<T>`的设计, 我们得先回忆一下在C语言中, 堆内存是怎么分配的

C需要使用malloc / calloc / realloc / free来处理内存的分配, 很多时候, 被分配出来的内存在函数调用中来来回回使用, 导致谁应该负责释放这件事很难确定, 给开发者造成极大的心智负担

C++在此基础上改进了一下, 提供了一个智能指针unique_ptr, 可以在指针退出作用域的时候释放堆内存, 这样保证了堆内存的单一所有权, 这个unique_ptr就是Rust的`Box<T>`的前身

你看`Box<T>`的定义里, 内部就是一个`Unique<T>`用于致敬C++, `Unique<T>`是一个私有的数据结构, 我们不能直接使用, 它包裹一个`*mut T`指针, 并唯一拥有这个指针

```rust
pub struct Unique<T: ?Sized> {
    pointer: *const T,
    _marker: PhantomData<T>,
}
```

我们知道, 在堆上分配内存, 需要使用内存分配器(Allocator), 如果你上过操作系统课程, 应该还记得一个简答的buddy system是如何分配和管理堆内存的

设计内存分配器的除了保证正确性之外, 就是为了有效的利用剩余内存, 并控制内存在分配和释放过程中产生的碎片的数量, 在多核环境下, 它还能够高效的处理并发请求

对上分配内存的`Box<T>`其实有一个缺省的泛型参数A, 就需要满足Allocator trait, 并且默认是Global

```rust
pub struct Box<T: ?Sized, A: Allocator = Global>(Unique<T>, A)
```

Allocator trait提供很多方法:

- allocate是主要方法, 用于分配内存, 对应C的malloc / calloc;
- deallocate, 用于释放内存, 对应C的free;
- 还有grow / shrink, 用来扩大或缩小堆上已分配的内存, 对应C的realloc

这里对Allocator trait我们就不详细介绍了, 如果你想替换默认的内存分配器, 可以使用`#[global_allocator]`标记宏, 定义你自己的全局分配器, 下面代码展示了如何在Rust下使用jemalloc;

```rust
use jemallocator::Jemalloc;

#[global_allocator]
static GLOBAL: Jemalloc = Jemalloc;
```

这样设置之后, 你使用`Box::new`分配的内存就是jemalloc分配出来的了, 另外, 如果你想撰写自己的全局分配器, 可以是按GlobalAlloc trait, 它和Allocator trait的区别, 主要在于是否允许分配长度为0的内存

### 使用场景

下面我们来实现一个自己的内存分配器, 别担心, 这里就是想debug一下, 看看内存如何分配和释放, 并不会实际实现摸一个分配算法

首先看看内存分配, 这里MyAllocator就是System allocator, 然后加`eprintln!()`, 和哦们常用的`println!()`不同的是, `eprintln!()`将数据打印到stderr

```rust
use std::alloc::{GlobalAlloc, Layout, System};

struct MyAllocator;

unsafe impl GlobalAlloc for MyAllocator {
    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {
        let data = System.alloc(layout);
        eprintln!("ALLOC: {:?}, size {}", data, layout.size());
        data
    }

    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {
        System.dealloc(ptr, layout);
        eprintln!("FREE: {:?}, size {}", ptr, layout.size());
    }
}

#[global_allocator]
static GLOBAL: MyAllocator = MyAllocator;

#[allow(dead_code)]
struct Matrix {
    data: [u8; 505],
}

impl Default for Matrix {
    fn default() -> Self {
        Self { data: [0; 505] }
    }
}

fn main() {
    // 在这句之前已经有好多内存分配
    let data = Box::new(Matrix::default());

    // 输出中有一个1024大小的内存分配, 是println!导致的
    println!(
        "!!! allocated memory: {:p}, len: {}",
        &*data,
        std::mem::size_of::<Matrix>()
    )

    // data到这里drop, 可以在打印中看到FREE
    // 之后还有很多其他内存被释放
}
```

注意这里不能使用`println!`, 因为stdout会打印到一个由Mutex互斥所保护的共享全局buffer中, 不过这个过程会设计内存的分配, 分配的内存又会触发`println!`, 最终造成程序崩溃, 而`eprintln!`知己打印到stderr, 不会buffer

运行这段代码, 你可以看到类似如下输出, 其中505大小的内存是我们`Box::new`出来的

```
❯ cargo run --bin allocator --quiet
ALLOC: 0x7fbe0dc05c20, size 4
ALLOC: 0x7fbe0dc05c30, size 5
FREE: 0x7fbe0dc05c20, size 4
ALLOC: 0x7fbe0dc05c40, size 64
ALLOC: 0x7fbe0dc05c80, size 48
ALLOC: 0x7fbe0dc05cb0, size 80
ALLOC: 0x7fbe0dc05da0, size 24
ALLOC: 0x7fbe0dc05dc0, size 64
ALLOC: 0x7fbe0dc05e00, size 505
ALLOC: 0x7fbe0e008800, size 1024
!!! allocated memory: 0x7fbe0dc05e00, len: 505
FREE: 0x7fbe0dc05e00, size 505
FREE: 0x7fbe0e008800, size 1024
FREE: 0x7fbe0dc05c30, size 5
FREE: 0x7fbe0dc05c40, size 64
FREE: 0x7fbe0dc05c80, size 48
FREE: 0x7fbe0dc05cb0, size 80
FREE: 0x7fbe0dc05dc0, size 64
```

在使用Box分配堆内存的时候需要注意, `Box::new`是一个函数, 所以传入它的数据会出现在栈上, 在移动到堆上, 所以, 如果我们的Matrix结构不是505个字节, 是一个非常大的数据结构, 就有可能出问题

比如下面的代码想在堆上分配16M内存, 如果你在playground里运行, 直接栈溢出

```rust
fn main() {
    // 在堆上分配 16M 内存，但它会现在栈上出现，再移动到堆上
    let boxed = Box::new([0u8; 1 << 24]);
    println!("len: {}", boxed.len());
}
```

但如果你在本地使用`cargo run --release`编译成release代码运行, 会正常执行

这是因为`cargo run`默认是debug build, 它不会做任何inlin的优化, 而`Box::new`的实现就一行代码, 并注明了要inline, 在release模式下, 这个函数调用会被优化掉

```rust
#[cfg(not(no_global_oom_handling))]
#[inline(always)]
#[doc(alias = "alloc")]
#[doc(alias = "malloc")]
#[stable(feature = "rust1", since = "1.0.0")]
pub fn new(x: T) -> Self {
    box x
}
```

如果不是inline, 整个16M的大数组会通过栈内存传递给Box::new, 导致栈溢出, 这里哦我们惊喜的发现一个新的关键字box, 然而box是Rust内部的管金子, 用户无法调用, 它只出现在Rust代码中, 用于分配堆内存, box关键字在编译时, 会使用内存分配器分配内存

搞明白`Box<T>`的内存分配, 我们还是很关心内存是如何释放的, 来看它实现的Drop trait

```rust
#[stable(feature = "rust1", since = "1.0.0")]
unsafe impl<#[may_dangle] T: ?Sized, A: Allocator> Drop for Box<T, A> {
    #[inline]
    fn drop(&mut self) {
        // the T in the Box is dropped by the compiler before the destructor is run

        let ptr = self.0;

        unsafe {
            let layout = Layout::for_value_raw(ptr.as_ptr());
            if layout.size() != 0 {
                self.1.deallocate(From::from(ptr.cast()), layout);
            }
        }
    }
}
```

